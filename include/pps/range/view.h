#ifndef PPS_RANGE_VIEW_H#define PPS_RANGE_VIEW_H#include <list>#include "viewIterator.h"namespace pps {namespace range {/*	Define a view as a range over a range T.	Thus, the only change will be on index retriving,	via the "begin" and "end" functions.	A view allow users to handle arrays through a	particular view:		std::vector<int> myTab;		// Retrieving element myTab[1][5].		int value = get(			view<2>(myTab)[view_subIndexes()[5][8][9][10]],			indexes<2>[0][0]		);	A specialization of a view could be made to	handle pure pointer types:		int*** myTab; // A 3x3x3 integer array.		// Retrieving the element myTab[0][0][0].		int value = get(			view<3>(myTab)[view_subRange(3)][view_subRange(3)][view_subRange(3)],			indexes<3>[0][0][0]		);*/template<class T, class SubView, int N>class view{	public:		typedef viewIterator<T, SubView, N> constIterator;		typedef viewIterator<T, SubView, N> iterator;	private:		T& m_range;		std::list<SubView> m_subViews;	public:		view(T& p_range);		view(const view<T, SubView, N>& p_view);		view<T, SubView, N>& operator[](const SubView& p_subRange);		constIterator begin() const;		iterator begin();		constIterator end() const;		iterator end();};}}namespace pps {namespace range {template<class T, class SubView, int N>view<T, SubView, N>::view(T& p_range): m_range(p_range){}template<class T, class SubView, int N>view<T, SubView, N>::view(const view<T, SubView, N>& p_view): m_range(p_view.m_range), m_subViews(p_view.m_subViews){}template<class T, class SubView, int N>typename view<T, SubView, N>::constIterator view<T, SubView, N>::begin() const{	return viewIterator<T, SubView, N>(m_range, m_subViews.begin());}template<class T, class SubView, int N>typename view<T, SubView, N>::iterator view<T, SubView, N>::begin(){	return viewIterator<T, SubView, N>(m_range, m_subViews.begin());}template<class T, class SubView, int N>typename view<T, SubView, N>::constIterator view<T, SubView, N>::end() const{	return viewIterator<T, SubView, N>(m_range, m_subViews.end());}template<class T, class SubView, int N>typename view<T, SubView, N>::iterator view<T, SubView, N>::end(){	return viewIterator<T, SubView, N>(m_range, m_subViews.end());}}}#endif