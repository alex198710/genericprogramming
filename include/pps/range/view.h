#ifndef PPS_RANGE_VIEW_H#define PPS_RANGE_VIEW_H#include <list>#include "traits.h"#include "traitsBaseType.h"namespace pps {namespace range {/*	Define a view as a range over a range T.	Thus, the only change will be on index retriving,	via the "begin" and "end" functions.	A view allow users to handle arrays through a	particular view:		std::vector<int> myTab;		// Retrieving element myTab[1][5].		int value = get(			view<2>(myTab)[view_subRange(1, 5, 2)][view_subIndexes()[5][8][9][10]],			indexes<2>[0][0]		);	A specialization of a view could be made to	handle pure pointer types:		int*** myTab; // A 3x3x3 integer array.		// Retrieving the element myTab[0][0][0].		int value = get(			view<3>(myTab)[view_subRange(3)][view_subRange(3)][view_subRange(3)],			indexes<3>[0][0][0]		);*/template<class T, class SubView, int N>class view{	public:		typedef const viewIterator<T, SubView, N> constIterator;		typedef viewIterator<T, SubView, N> iterator;	private:		T& m_range;		std::list<SubView> m_subViews;	public:		view(T& p_range);		view(const view<T, SubView, N>& p_view);		view<T, SubView, N>& operator[](const SubView& p_subRange);		constIterator begin() const;		iterator begin();		constIterator end() const;		iterator end();};// ---------------------------------------------------------//viewIterator<traits<T,N>::value_type> view.begin()template<class T, class SubView>class view{	public:		typedef const viewIterator<T, SubRange> constIterator;		typedef viewIterator<T, SubRange> iterator;	private:		T& m_range;		SubRange m_subRange;	public:		view(T& p_range, const SubRange& p_subRange);		view(const view<T, N>& p_view);		constIterator begin() const;		iterator begin();		constIterator end() const;		iterator end();};template<class T, class SubRange>class viewIterator{	private:		traits<T>::iterator m_data;		traits<SubRange>::iterator m_indexes;	public:		viewIterator(const viewIterator& p_);};}}namespace pps {namespace range {template<class T, int N>view<T, N>::view(T& p_range): m_range(p_range){}template<class T, int N>view<T, N>::view(const view<T, N>& p_view): m_range(p_view.m_range), m_data(p_view.m_data){}template<class T, int N>constIterator view<T, N>::begin() const{	return m_data.begin();}template<class T, int N>iterator view<T, N>::begin(){	return m_data.begin();}template<class T, int N>constIterator view<T, N>::end() const{	return m_data.end();}template<class T, int N>iterator view<T, N>::end(){	return m_data.end();}}}#endif