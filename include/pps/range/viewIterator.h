#ifndef PPS_RANGE_VIEW_ITERATOR_H#define PPS_RANGE_VIEW_ITERATOR_H#include <list>#include "traits.h"#include "begin.h"namespace pps {namespace range {template<class T, class SubView, int N>class viewIterator	: public std::iterator<std::forward_iterator_tag, std::size_t>{	public:		typedef typename std::list<SubView>::const_iterator iteratorSubViews;		typedef typename traits<T>::iterator iteratorData;		typedef typename traits<SubView>::constIterator iteratorIndexes;		typedef viewIterator<typename traits<T>::valueType, SubView, N-1> childViewIterator;	private:		iteratorSubViews m_itSubViews;		iteratorData m_itData;		iteratorIndexes m_itIndexes;		std::size_t m_index;	public:		viewIterator(T& p_range, const iteratorSubViews& p_itSubViews);		viewIterator(const viewIterator<T, SubView, N>& p_viewIterator);		viewIterator<T, SubView, N>& operator=(const viewIterator<T, SubView, N>& p_viewIterator);		bool operator==(const viewIterator<T, SubView, N>& p_viewIterator) const;		bool operator!=(const viewIterator<T, SubView, N>& p_viewIterator) const;		viewIterator<T, SubView, N>& operator++();		viewIterator<T, SubView, N> operator++(int);		childViewIterator operator*() const;};}}namespace pps {namespace range {template<class T, class SubView, int N>viewIterator<T, SubView, N>::viewIterator(T& p_range, const iteratorSubViews& p_itSubViews): m_itSubViews(p_itSubViews), m_itData(begin(p_range)), m_itIndexes(begin(*m_itSubViews)), m_index(0){}template<class T, class SubView, int N>viewIterator<T, SubView, N>::viewIterator(const viewIterator<T, SubView, N>& p_viewIterator): m_itSubViews(p_viewIterator.m_itSubViews), m_itData(p_viewIterator.m_itData), m_itIndexes(begin(*m_itSubViews)), m_index(0){}template<class T, class SubView, int N>viewIterator<T, SubView, N>& viewIterator<T, SubView, N>::operator=(const viewIterator<T, SubView, N>& p_viewIterator){	if(*p_viewIterator == this)		return *this;	m_itSubViews = p_viewIterator.m_itSubViews;	m_itData = p_viewIterator.m_itData;	m_itIndexes = p_viewIterator.m_itIndexes;	m_index = p_viewIterator.m_index;	return *this;}template<class T, class SubView, int N>bool viewIterator<T, SubView, N>::operator==(const viewIterator<T, SubView, N>& p_viewIterator) const{	return m_itSubViews == p_viewIterator.m_itSubViews && m_itIndexes == p_viewIterator.m_itIndexes;}template<class T, class SubView, int N>bool viewIterator<T, SubView, N>::operator!=(const viewIterator<T, SubView, N>& p_viewIterator) const{	return m_itSubViews != p_viewIterator.m_itSubViews || m_itIndexes != p_viewIterator.m_itIndexes;}template<class T, class SubView, int N>viewIterator<T, SubView, N>& viewIterator<T, SubView, N>::operator++(){	++m_itIndexes;	std::size_t newIndex = *m_itIndexes;	for(; m_index < newIndex ; ++m_index)		++m_itData;	for(; m_index > newIndex ; --m_index)		--m_itData;	return *this;}template<class T, class SubView, int N>viewIterator<T, SubView, N> viewIterator<T, SubView, N>::operator++(int){	viewIterator<T, SubView, N> oldIterator(*this);	++m_itIndexes;	std::size_t newIndex = *m_itIndexes;	for(; m_index < newIndex ; ++m_index)		++m_itData;	for(; m_index > newIndex ; --m_index)		--m_itData;	return oldIterator;}template<class T, class SubView, int N>typename viewIterator<T, SubView, N>::childViewIterator viewIterator<T, SubView, N>::operator*() const{	iteratorSubViews childItSubViews(m_itSubViews);	++childItSubViews;	return childViewIterator(		*m_itData,		childItSubViews	);}template<class T, class SubView>typename traits<T>::valueType viewIterator<T, SubView, 1>::operator*() const{	return *m_data;}}}#endif