#ifndef PPS_RANGE_VIEW_ITERATOR_H#define PPS_RANGE_VIEW_ITERATOR_H#include <list>#include "traits.h"namespace pps {namespace range {template<class T, class SubView, int N>class viewIterator{	public:		typedef typename std::list<SubView>::const_iterator iteratorSubViews;		typedef typename traits<T>::constIterator constIteratorData;		typedef typename traits<T>::iterator iteratorData;		typedef typename traits<SubView>::constIterator iteratorIndexes;	private:		T& m_range;		iteratorSubViews m_itSubViews;		iteratorData m_itData;		iteratorIndexes m_itIndexes;	public:		viewIterator(T& p_range, const iteratorSubViews& p_itSubViews);		viewIterator(const viewIterator<T, SubView, N>& p_viewIterator);		viewIterator<T, SubView, N>& operator++();		viewIterator<T, SubView, N> operator++();		const viewIterator<T, SubView, N-1> operator*() const;		viewIterator<T, SubView, N-1> operator*();};}}namespace pps {namespace range {template<class T, class SubView, int N>viewIterator<T, SubView, N>::viewIterator(T& p_range, const iteratorSubViews& p_itSubViews): m_range(p_range), m_itSubViews(p_itSubViews), m_itData(begin(p_range)), m_itIndexes(*m_itSubViews){}template<class T, class SubView, int N>viewIterator<T, SubView, N>::viewIterator(const viewIterator<T, SubView, N>& p_viewIterator): m_range(p_viewIterator.m_range), m_itSubViews(p_viewIterator.m_itSubViews), m_itData(begin(p_viewIterator.m_range)), m_itIndexes(*m_itSubViews){}template<class T, class SubView>constIteratorData viewIterator<T, SubView, 1>::operator*() consttemplate<class T, class SubView>constIteratorData viewIterator<T, SubView, 1>::operator*() const}}#endif