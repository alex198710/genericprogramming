#ifndef PPS_RANGE_END_H#define PPS_RANGE_END_H#include "traits.h"namespace pps {namespace range {/*	Those functions allow the user to extract an iterator	on "past" the last element of the range.	Those functions HAVE to be overridden for the library	internal use.*/template<class T>typename traits<T>::constIteratorend(const T& p_range){	/*	-----------------------------------------------------------------		If an assertion occurs here, it means that you don't have		overridden the end function that returns a constant		iterator for your user-made type.		Extension example:		----			// A user-made class that behave like			// an array of integers.			class MyClass			{				public:					typedef int myValueType;					typedef const int& myConstReference;					typedef int& myReference;					typedef const int* myConstIterator;					typedef int* myIterator;			};			namespace pps {			namespace range {			inline			typename traits<T>::constIterator			end(const MyClass& p_range)			{				// User-provided code.			}			}}		----	--------------------------------------------------------------------	*/	static_assert(!std::is_same<T, T>::value, "[pps::range::end]: Missing specialization for [constIterator range::end] function");}template<class T>typename traits<T>::iteratorend(T& p_range){	/*	-----------------------------------------------------------------		If an assertion occurs here, it means that you don't have		overridden the end function that returns an iterator for		your user-made type.		Extension example:		----			// A user-made class that behave like			// an array of integers.			class MyClass			{				public:					typedef int myValueType;					typedef const int& myConstReference;					typedef int& myReference;					typedef const int* myConstIterator;					typedef int* myIterator;			};			namespace pps {			namespace range {			inline			typename traits<T>::iterator			end(MyClass& p_range)			{				// User-provided code.			}			}}		----	--------------------------------------------------------------------	*/	static_assert(!std::is_same<T, T>::value, "[pps::range::end]: Missing specialization for [iterator range::end] function");}}}// ---- Standart specializationsnamespace pps {namespace range {/*	Those specializations doesn't work for now.	The language doesn't match the end functions	for T[N] types.template<class T, int N>inlinetypename traits<T[N]>::constIteratorend(const T p_range[N]){	return p_range + N;}template<class T, int N>inlinetypename traits<T[N]>::iteratorend(T p_range[N]){	return p_range + N;}*/}}// ---- STL specializations#include <vector>#include <list>#include <deque>#include <set>#include <map>namespace pps {namespace range {// -- std::vectortemplate<class T>inlinetypename traits<std::vector<T>>::constIteratorend(const std::vector<T>& p_range){	return p_range.end();}template<class T>inlinetypename traits<std::vector<T>>::iteratorend(std::vector<T>& p_range){	return p_range.end();}// -- std::listtemplate<class T>inlinetypename traits<std::list<T>>::constIteratorend(const std::list<T>& p_range){	return p_range.end();}template<class T>inlinetypename traits<std::list<T>>::iteratorend(std::list<T>& p_range){	return p_range.end();}// -- std::dequetemplate<class T>inlinetypename traits<std::deque<T>>::constIteratorend(const std::deque<T>& p_range){	return p_range.end();}template<class T>inlinetypename traits<std::deque<T>>::iteratorend(std::deque<T>& p_range){	return p_range.end();}// -- std::settemplate<class T>inlinetypename traits<std::set<T>>::constIteratorend(const std::set<T>& p_range){	return p_range.end();}template<class T>inlinetypename traits<std::set<T>>::iteratorend(std::set<T>& p_range){	return p_range.end();}// -- std::multisettemplate<class T>inlinetypename traits<std::multiset<T>>::constIteratorend(const std::multiset<T>& p_range){	return p_range.end();}template<class T>inlinetypename traits<std::multiset<T>>::iteratorend(std::multiset<T>& p_range){	return p_range.end();}// -- std::maptemplate<class Key, class T>inlinetypename traits<std::map<Key, T>>::constIteratorend(const std::map<Key, T>& p_range){	return p_range.end();}template<class Key, class T>inlinetypename traits<std::map<Key, T>>::iteratorend(std::map<Key, T>& p_range){	return p_range.end();}// -- std::multimaptemplate<class Key, class T>inlinetypename traits<std::multimap<Key, T>>::constIteratorend(const std::multimap<Key, T>& p_range){	return p_range.end();}template<class Key, class T>inlinetypename traits<std::multimap<Key, T>>::iteratorend(std::multimap<Key, T>& p_range){	return p_range.end();}}}#endif