#ifndef PPS_RANGE_GET_H#define PPS_RANGE_GET_H#include "traits.h"#include "traitsBaseType.h"#include "indexes.h"#include "begin.h"template<int N, class T, class Indexes>const traitsBaseType<T, N>::baseTypeget(const T& p_range, const Indexes& p_indexes){	typename traits<T>::constIterator itData(begin(p_range));	typename traits<Indexes>::constIterator itIndexes(begin(p_indexes));	return get();}/*template<class MultiArray, class Indexes>get(const MultiArray& p_multiArray, const Indexes& p_indexes){	typename range<Indexes>::constIterator itIndexes(begin(p_indexes));	typename range<MultiArray>::constIterator itData(begin(p_multiArray));	for(std::size_t i = 0, end = *itIndexes ; i < end ; ++i)		++itData;	return *itData;}template<class MultiArray, class View, class Indexes>get(const MultiArray& p_multiArray, const View& p_view, const Indexes& p_indexes){	typename range<View>::constIterator itView(begin(p_view));	typedef typename range<View>::valueType SubView;	typename range<SubView>::constIterator itSubView(begin(*itView));	typename range<Indexes>::constIterator itIndexes(begin(p_indexes));	for(std::size_t i = 0, end = *itIndexes ; i < end ; ++i)		++itSubView;	typename range<MultiArray>::constIterator itData(begin(p_multiArray));	for(std::size_t i = 0, end = *itSubView ; i < end ; ++i)		++itData;	return *itData;}*/#endif