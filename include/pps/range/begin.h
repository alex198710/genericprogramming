#ifndef PPS_RANGE_BEGIN_H#define PPS_RANGE_BEGIN_H#include "traits.h"namespace pps {namespace range {/*	Those functions allow the user to extract an iterator	on the first element of the range.	Those functions HAVE to be overridden for the library	internal use.*/template<class T>typename traits<T>::constIteratorbegin(const T& p_range){	/*	-----------------------------------------------------------------		If an assertion occurs here, it means that you don't have		overridden the begin function that returns a constant		iterator for your user-made type.		Extension example:		----			// A user-made class that behave like			// an array of integers.			class MyClass			{				public:					typedef int myValueType;					typedef const int& myConstReference;					typedef int& myReference;					typedef const int* myConstIterator;					typedef int* myIterator;			};			namespace pps {			namespace range {			inline			typename traits<T>::constIterator			begin(const MyClass& p_range)			{				// User-provided code.			}			}}		----	--------------------------------------------------------------------	*/	static_assert(!std::is_same<T, T>::value, "[pps::range::begin]: Missing specialization for [constIterator range::begin] function");}template<class T>typename traits<T>::iteratorbegin(T& p_range){	/*	-----------------------------------------------------------------		If an assertion occurs here, it means that you don't have		overridden the begin function that returns an iterator for		your user-made type.		Extension example:		----			// A user-made class that behave like			// an array of integers.			class MyClass			{				public:					typedef int myValueType;					typedef const int& myConstReference;					typedef int& myReference;					typedef const int* myConstIterator;					typedef int* myIterator;			};			namespace pps {			namespace range {			inline			typename traits<T>::iterator			begin(MyClass& p_range)			{				// User-provided code.			}			}}		----	--------------------------------------------------------------------	*/	static_assert(!std::is_same<T, T>::value, "[pps::range::begin]: Missing specialization for [iterator range::begin] function");}}}// ---- Standart specializationsnamespace pps {namespace range {template<class T>inlinetypename traits<T*>::constIteratorbegin(const T* p_range){	return p_range;}template<class T>inlinetypename traits<T*>::iteratorbegin(T* p_range){	return p_range;}/*	Those specializations doesn't work for now.	The language doesn't match the begin functions	for T[N] types.template<class T, int N>inlinetypename traits<T[N]>::constIteratorbegin(const T p_range[N]){	return p_range;}template<class T, int N>inlinetypename traits<T[N]>::iteratorbegin(T p_range[N]){	return p_range;}*/}}// ---- STL specializations#include <vector>#include <list>#include <deque>#include <set>#include <map>namespace pps {namespace range {// -- std::vectortemplate<class T>inlinetypename traits<std::vector<T>>::constIteratorbegin(const std::vector<T>& p_range){	return p_range.begin();}template<class T>inlinetypename traits<std::vector<T>>::iteratorbegin(std::vector<T>& p_range){	return p_range.begin();}// -- std::listtemplate<class T>inlinetypename traits<std::list<T>>::constIteratorbegin(const std::list<T>& p_range){	return p_range.begin();}template<class T>inlinetypename traits<std::list<T>>::iteratorbegin(std::list<T>& p_range){	return p_range.begin();}// -- std::dequetemplate<class T>inlinetypename traits<std::deque<T>>::constIteratorbegin(const std::deque<T>& p_range){	return p_range.begin();}template<class T>inlinetypename traits<std::deque<T>>::iteratorbegin(std::deque<T>& p_range){	return p_range.begin();}// -- std::settemplate<class T>inlinetypename traits<std::set<T>>::constIteratorbegin(const std::set<T>& p_range){	return p_range.begin();}template<class T>inlinetypename traits<std::set<T>>::iteratorbegin(std::set<T>& p_range){	return p_range.begin();}// -- std::multisettemplate<class T>inlinetypename traits<std::multiset<T>>::constIteratorbegin(const std::multiset<T>& p_range){	return p_range.begin();}template<class T>inlinetypename traits<std::multiset<T>>::iteratorbegin(std::multiset<T>& p_range){	return p_range.begin();}// -- std::maptemplate<class Key, class T>inlinetypename traits<std::map<Key, T>>::constIteratorbegin(const std::map<Key, T>& p_range){	return p_range.begin();}template<class Key, class T>inlinetypename traits<std::map<Key, T>>::iteratorbegin(std::map<Key, T>& p_range){	return p_range.begin();}// -- std::multimaptemplate<class Key, class T>inlinetypename traits<std::multimap<Key, T>>::constIteratorbegin(const std::multimap<Key, T>& p_range){	return p_range.begin();}template<class Key, class T>inlinetypename traits<std::multimap<Key, T>>::iteratorbegin(std::multimap<Key, T>& p_range){	return p_range.begin();}}}#endif