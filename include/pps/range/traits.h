#ifndef PPS_RANGE_TRAITS_H#define PPS_RANGE_TRAITS_Hnamespace pps {namespace range {/*	Extensibility entry point of the library.	The choice made here is that an array can be viewed	as a range of elements. Here, we specified one or two	things about a range, like the base element type it	handles, its iterators types... and so on.*/template<class T>struct traits{	typedef T valueType;	typedef const T& constReference;	typedef T& reference;	typedef const T* constIterator;	typedef T* iterator;	/*	-----------------------------------------------------------------		If an assertion occurs here, it means that you don't have		specialized the traits structure for your user-made type.		Extension example:		----			// A user-made class that behave like			// an array of integers.			class MyClass			{				public:					typedef int myValueType;					typedef const int& myConstReference;					typedef int& myReference;					typedef const int* myConstIterator;					typedef int* myIterator;			};			namespace pps {			namespace range {			template<class T>			struct traits<MyClass>			{				typedef typename MyClass::myValueType valueType;				typedef typename MyClass::myConstReference constReference;				typedef typename MyClass::myReference reference;				typedef typename MyClass::myConstIterator constIterator;				typedef typename MyClass::myIterator iterator;			};			}}		----	--------------------------------------------------------------------	*/	static_assert(!std::is_same<T, T>::value, "[pps::range::traits_base]: Missing specialization for [traits_base] structure");};}}// ---- Standart specializationsnamespace pps {namespace range {template<class T>struct traits<T*>{	typedef T valueType;	typedef const T& constReference;	typedef T& reference;	typedef const T* constIterator;	typedef T* iterator;};template<class T>struct traits<T[]>{	typedef T valueType;	typedef const T& constReference;	typedef T& reference;	typedef const T* constIterator;	typedef T* iterator;};template<class T, int N>struct traits<T[N]>{	typedef T valueType;	typedef const T& constReference;	typedef T& reference;	typedef const T* constIterator;	typedef T* iterator;};}}// ---- STL specializations#include <vector>#include <list>#include <deque>#include <set>#include <map>namespace pps {namespace range {template<class T>struct traits_stl{	typedef typename T::value_type valueType;	typedef typename T::const_reference constReference;	typedef typename T::reference reference;	typedef typename T::const_iterator constIterator;	typedef typename T::iterator iterator;};template<class T> struct traits<std::vector<T>>		: traits_stl<std::vector<T>>	{};template<class T> struct traits<std::list<T>>		: traits_stl<std::list<T>>		{};template<class T> struct traits<std::deque<T>>		: traits_stl<std::deque<T>>		{};template<class T> struct traits<std::set<T>>		: traits_stl<std::set<T>>		{};template<class T> struct traits<std::multiset<T>>	: traits_stl<std::multiset<T>>	{};template<class Key, class T> struct traits<std::map<Key, T>>		: traits_stl<std::map<Key, T>>		{};template<class Key, class T> struct traits<std::multimap<Key, T>>	: traits_stl<std::multimap<Key, T>>	{};}}#endif