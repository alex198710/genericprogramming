#ifndef PPS_RANGE_VIEW_SUB_H#define PPS_RANGE_VIEW_SUB_Hnamespace pps {namespace range {class view_subIterator	: public std::iterator<std::forward_iterator_tag, std::size_t>{	public:		typedef std::size_t valueType;		typedef const std::size_t& constReference;		typedef std::size_t& reference;	private:		std::size_t m_index;	public:		view_subIterator(std::size_t p_index);		view_subIterator(const view_subIterator& p_iterator);		view_subIterator& operator=(const view_subIterator& p_iterator);		view_subIterator& operator++();		view_subIterator operator++();		constReference operator*();		reference operator*();};class view_sub{	public:		typedef view_subIterator constIterator;		typedef const view_subIterator iterator;	private:		std::size_t m_begin;		std::size_t m_end;	public:		view_sub(std::size_t p_end);		view_sub(std::size_t p_begin, std::size_t p_end);		view_sub(const view_sub& p_viewSub);		view_sub& operator=(const view_sub& p_viewSub);		constIterator begin() const;		iterator begin() const;		constIterator end() const;		iterator end() const;};// ---- Extends library to support view_sub as a rangetemplate<class T>struct traits_base<view_sub<T>>{	typedef T std::size_t;	typedef const std::size_t& constReference;	typedef std::size_t& reference;	typedef typename view_sub::constIterator constIterator;	typedef typename view_sub::iterator iterator;};template<class T>range<T>::constIteratorbegin(const view_sub<T>& p_range){	return p_range.begin();}template<class T>range<T>::iteratorbegin(view_sub<T>& p_range){	return p_range.begin();}template<class T>range<T>::constIteratorend(const view_sub<T>& p_range){	return p_range.end();}template<class T>range<T>::iteratorend(view_sub<T>& p_range){	return p_range.end();}}}#endif